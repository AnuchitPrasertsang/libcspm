
-- compression09.csp

-- This DRAFT file supports various semi-automated compression techniques over
-- CSP networks for use with FDR.  

-- It it is designed to accompany the author's forthcoming book
-- "Understanding Concurrency"
-- and is an updated version of the 1997 file "compresion.csp" that
-- accompanied "Theory and Practice of Concurrency".

-- Bill Roscoe

-- We assume that networks are presented to us as 
-- structures comprising process/alphabet pairs arranged in list
-- arrangements,

-- or (09) as members of the structured datatype

datatype PStruct = PSLeaf.(Proc,Set(Events)) | PSNode.Seq(PStruct)

-- This can only be used with FDR 2.91 and up where processes (Proc) are allowed
-- as parts of user-defined types.

-- We may (subject to alterations to FDR) be able to support more complex
-- structured types over processes.

-- The alphabet of any such list is the union of the alphabets of
-- the component processes:

alphabet(ps) = Union(set(<A | (P,A) <- ps>))

-- The vocabulary of a list is the set of events that are synchronised
-- between at least two members:

vocabulary(ps) = if #ps<2 then {} else
                 let A = snd(head(ps))
		     V = vocabulary(tail(ps))
		     A' = alphabet(tail(ps))
		 within
		     union(V,inter(A,A'))

-- The following is a function 
-- that composes a process/alphabet list without any
-- compression:

ListPar(ps) = let N=#ps within
              || i:{0..N-1} @ [snd(cnth(i,ps))] fst(cnth(i,ps))

-- The most elementary transformation we can do on a network is to
-- hide all events in individual processes that are neither relevant to
-- the specification nor are required for higher synchronisation.
-- The following function takes as its (curried) arguments a compression
-- function to apply at the leaves, a process/alphabet list to compose
-- in parallel and a set of events which it is desired to hide (either
-- because they are genuinely internal events or irrelevant to the spec).
-- It hides as much as it can in the processes, but does not combine them

CompressLeaves(compress)(ps)(X) = let V = vocabulary(ps) 
                                    N = #ps
				    H = diff(X,V)
				within
		  <(compress(P\inter(A,H)),diff(A,H)) | (P,A) <- ps>

-- The following uses this to produce a combined process

LeafCompress(compress)(ps)(X) = ListPar(CompressLeaves(compress)(ps)(X))\X

-- It is often advantageous to be able to apply lazy or mixed abstraction
-- operators in the same sort of way as the above does for hiding.  The
-- following are two functions that generalize the above: they take a
-- pair of event-sets (X,S): X is the set we want to abstract and S is
-- the set of signal events (which need not be a subset of X).  The
-- result is that inter(X,S) is hidden and diff(X,S) is lazily
-- abstracted.   Note that you can get the effect of pure hiding (eager
-- abstraction by setting S=Events) and pure lazy abstraction by setting
-- S={}.  Note also, however, that if you are trying to lazily abstract
-- a network with some natural hiding in it, that all these hidden events
-- should be treated as signals.

LeafMixedAbs(compress)(ps)(X,S) = 
                           let V = vocabulary(ps) 
                               N = #ps
                               D = diff(X,S)
                               H'= diff(X,V)
                           within
		  <(compress((P[|inter(A,D)|] 
		    compress(CHAOS(inter(A,D))))\inter(A,H')),diff(A,H')) 
				 | (P,A) <- ps>

-- The substantive function is then:

MixedAbsLeafCompress(compress)(ps)(X,S) = 
       ListPar(LeafMixedAbs(compress)(ps)(X,S))\X


-- The next transformation builds up a list network in the order defined
-- in the (reverse of) the list, applying a specified compression function
-- to each partially constructed unit.

InductiveCompress(compress)(ps)(X) = 
        compress(IComp(compress)(CompressLeaves(compress)(ps)(X))(X))

IComp(compress)(ps)(X) = let  p = head(ps)
			       P = fst(p)
			       A = snd(p)
			       A' = alphabet(ps')
			       ps' = tail(ps)
			  within
                           if #ps == 1 then P\X
			   else
			   let Q = IComp(compress)(ps')(diff(X,A))
                           within
			       (P[A||A']compress(Q))\inter(X,A)

InductiveMixedAbs(compress)(ps)(X,S) = 
        compress(IComp(compress)(LeafMixedAbs(compress)(ps)(X,S))(X))

-- Sometimes compressed subnetworks grow to big to make the above
-- function conveniently applicable.  The following function allows you
-- to compress each of a list-of-lists of processes, and then
-- combine them all without trying to compress any further.

StructuredCompress(compress)(pss)(X) =
                         let N = #pss
			 as = <alphabet(ps) | ps <- pss>
			 ss = <Union({inter(cnth(i,as),cnth(j,as)) | 
				j <- {0..N-1}, j!=i}) | i <- <0..N-1>>  
			 within
			 (ListPar(<(compress(
				 InductiveCompress(compress)(cnth(i,
					  pss))(diff(X,cnth(i,ss)))
					     \(diff(X,cnth(i,ss)))),
					cnth(i,as)) | i <- <0..N-1>>))\X

-- The analogue of ListPar

StructuredPar(pss) =  ListPar(<(ListPar(ps),alphabet(ps)) | ps <- pss>)

-- and the mixed abstraction analogue:

StructuredMixedAbs(compress)(pss)(X,S) =
                         let N = #pss
			 as = <alphabet(ps) | ps <- pss>
			 ss = <Union({inter(cnth(i,as),cnth(j,as)) | 
				j <- {0..N-1}, j!=i}) | i <- <0..N-1>>  
			 within
			 (ListPar(<(compress(
				 InductiveMixedAbs(compress)(cnth(i,
					  pss))(diff(X,cnth(i,ss)),S)
					     \(diff(X,cnth(i,ss)))),
					cnth(i,as)) | i <- <0..N-1>>))\X

-- The following are some functional programming constructs used above

cnth(i,xs) = if i==0 then head(xs) 
                    else cnth(i-1,tail(xs))
        
fst((x,y)) = x
snd((x,y)) = y

-- The following function can be useful for partitioning a process list
-- into roughly equal-sized pieces for structured compression

groupsof(n)(xs) = let xl=#xs within
                  if xl==0 then <> else
                  if xl<=n or n==0 then <xs>
                  else let 
                         m=if (xl/n)*n==xl then n else (n+1)
                    within
                    <take(m)(xs)>^groupsof(n)(drop(m)(xs))

take(n)(xs) = if n==0 then <> else <head(xs)>^take(n-1)(tail(xs))

drop(n)(xs) = if n==0 then xs else drop(n-1)(tail(xs))

-- The following define some similar compression functions for PStruct


StructPar(t) = let (P,_) = SPA(t) within P

SPA(PSLeaf.(P,A)) = (P,A)

SPA(PSNode.ts) = let ps = <SPA(t) | t <- ts> 
                     A = Union(set(<a | (_,a)  <- ps>))
                  within
                  (ListPar(ps),A)

PSmap(f,PSLeaf.p) = PSLeaf.(f(p))
PSmap(f,PSNode.ts) = PSNode.<PSmap(f,t) | t <- ts>

PSvocab(t) = let as = psalphas(t)
             within
               Union({inter(cnth(i,as),cnth(j,as)) |
                              i <- {1..(#as)-1}, j <- {0..i-1}})

psalphas(PSLeaf.(P,A)) = <A>
psalphas(PSNode.ts) = <A | u <- ts, A <- psalphas(u)>
--psalphas(PSNode.ts) = <>

CompressPSLeaves(compress)(t)(X) = let V = PSvocab(t)
                                       H = diff(X,V)
                                       f((P,A)) = (compress(P\H),A)
                                   within
                                   PSmap(f,t)

PSLeafCompress(compress)(t)(X) = let ct = CompressPSLeaves(compress)(t)(X)
                                 within
                                 StructPar(ct)\X

psalphabet(PSLeaf.(P,A)) = A
psalphabet(PSNode.ts) = let AS = <psalphabet(t) | t <- ts>
                            within Union(set(AS))


PSStructCompress(compress) =
      let G(PSLeaf.(P,A)) = let f(X) = P\X within f
          G(PSNode.ts) =  \X @
                             let as = <psalphabet(t) | t <- ts>
                                 tlv = Union({inter(cnth(i,as),cnth(j,as)) |
                                              i <- {1..#ts-1}, j <- {0..i-1}})

                                 ps = <(compress(PSStructCompress(compress)(t)(
                                       inter(psalphabet(t), diff(X,tlv)))), 
                                       psalphabet(t)) 
                                       | t <- ts >
                              within
                               ListPar(ps)\X
        within G


channel assertionfailed
channel collision
Signals = {| assertionfailed, collision|}

ISignals = Union ({})
ivnums = {1..9}
bvnums = {1..1}
ianums = {1..2}
banums = {1..0}
DirtyVars = Union({{IA.2.x | x <- ditype },{IV.2},{IV.1},{IA.1.x | x <- {0..3}}})
ctypes = <>
catypes = <>
itypes = <(IA.1, {0..3})>
init = (<>,<>)
LocalIVarMapping_Reader_outp() = IV.5
LocalIVarMapping_Reader_rindex() = IV.4
LocalIVarMapping_Reader_rpair() = IV.3
LocalIVarMapping_Writer_inp() = IV.8
LocalIVarMapping_Writer_windex() = IV.7
LocalIVarMapping_Writer_wpair() = IV.6
LocalIVarMapping_Writer_wval() = IV.9
ParReads = Union({})
ParWrites = Union({})
SeqReads = Union({})
SeqWrites = Union({})

mostprocs = 2
ext_atomic=false
MinI = 0
MaxI = 4
InitB = false
InitI = 0
ditype = {0,1}
dctype = {0,1}
Reader() = (Iter.Sq.(Iassign.(IVar.LocalIVarMapping_Reader_rpair(),BIOp.Mod.IVar.IV.2.Const.2),Sq.(Iassign.(IVar.IV.1,IVar.LocalIVarMapping_Reader_rpair()),Sq.(Iassign.(IVar.LocalIVarMapping_Reader_rindex(),BIOp.Mod.IArc.(IA.2,IVar.LocalIVarMapping_Reader_rpair()).Const.2),Sq.(Iassign.(IVar.LocalIVarMapping_Reader_outp(),IArc.(IA.1,BIOp.Plus.BIOp.Times.Const.2.IVar.LocalIVarMapping_Reader_rpair().IVar.LocalIVarMapping_Reader_rindex())),Cond.(CompOp.Eq.IVar.LocalIVarMapping_Reader_outp().Const.1,Sig.collision,Skip)))))
, (Union({{IVar.LocalIVarMapping_Reader_rpair(),IVar.LocalIVarMapping_Reader_rindex(),IVar.LocalIVarMapping_Reader_outp()}}),Union({{}})))
Writer() = (Iter.Sq.(Iassign.(IVar.LocalIVarMapping_Writer_wval(),IVar.LocalIVarMapping_Writer_inp()),Sq.(Iassign.(IVar.LocalIVarMapping_Writer_wpair(),BIOp.Minus.Const.1.BIOp.Mod.IVar.IV.1.Const.2),Sq.(Iassign.(IVar.LocalIVarMapping_Writer_windex(),BIOp.Minus.Const.1.BIOp.Mod.IArc.(IA.2,IVar.LocalIVarMapping_Writer_wpair()).Const.2),Sq.(Iassign.(IArc.(IA.1,BIOp.Plus.BIOp.Times.Const.2.IVar.LocalIVarMapping_Writer_wpair().IVar.LocalIVarMapping_Writer_windex()),IVar.LocalIVarMapping_Writer_wval()),Sq.(Iassign.(IArc.(IA.2,IVar.LocalIVarMapping_Writer_wpair()),IVar.LocalIVarMapping_Writer_windex()),Iassign.(IVar.IV.2,IVar.LocalIVarMapping_Writer_wpair()))))))
, (Union({{IVar.LocalIVarMapping_Writer_wpair(),IVar.LocalIVarMapping_Writer_windex(),IVar.LocalIVarMapping_Writer_inp(),IVar.LocalIVarMapping_Writer_wval()}}),Union({{}})))
WideStruct = HierarchCompressedCompile(CSNode.<CSLeaf.Reader(),CSLeaf.Writer()>) ({| c | c <-Union({Signals,ISignals,Errors}) |})
assert  STOP [T= WideStruct 

-- svaref.csp

-- Bill Roscoe, July 2009 amended October 2010

-- A front-end to svacomp.csp that allows refinement testing between
-- the behaviours of partial systems.

-- When you may wish to perform refinement checks between shared variable
-- programs you should include this program, which in turn includes the
-- main compiler:


-- At the time of writing SVA always uses the present file, since it
-- does not remove any functionality.

-- Refinement is more involved than testing whole threads, because we have to
-- take into account both the inter- and intra- thread ways our target
-- code interacts with others.  The logic behind what this file does is
-- explained in Chapter 19 of Understanding Concurrent Systems.

-- This program expects to support checks of the form

-- assert SeqRefTest(P) [T= SeqRefTest(P)
-- assert OTRefTest(P) [T= OTRefTest(P)
-- assert GenRefTest(P) [T= GenRefTest(P)

-- respectively representing refinement checking of a partial
-- system in sequential, parallel and general contexts.

-- Because of the syntactic structure of SVL programs, the first
-- and last of these expect P to be Cmd, while the middle one (in order
-- to allow P to contain parallelism) has P an SCStruct.


-- ParReads: includes all locations written by this code segment that
-- can be read by another thread.  Should be {} for sequential contexts.

-- ParWrites: includes all locations read by this Cmd that can be written
-- by another thread.  Should be {} for sequential contexts.

-- SeqReads: includes all locations read by this Cmd that might, at the
-- start of its execution, have been written to some value other than the
-- standard initialisation. Should be {} for parallel contexts.

-- SeqWrites: includes all locations written by the Cmd that might
-- be read by some piece of code that runs sequentially after our Cmd.
-- Should be {} for parallel contexts.

-- ext_atomic: Boolean which is true if other parallel threads might
-- go into an atomic section in the middle of the code we are testing.

-- These are all the ways in which our program can be influenced by or
-- influence the execution


-- We model external reads and writes much as before, but need to be able
-- to see the initial state our Cmd P runs from in the trace, and to be able to
-- see any relevant final values of locations in the trace also.

-- We therefore divide time into three periods: an initial one that established
-- the initialisation, the main one in which P runs, and a final one in
-- which the final values of locations in SeqWrites become apparent.

-- This is done by running a modified version of P in which the three
-- phases are divided by signals, where the external channel -1 is used
-- for reading and writing all the locations in all the four sets above,
-- and where which of these actions can happen when is governed by parallel
-- composition with a regulator process

ExtReads = union(ParReads,SeqReads)
ExtWrites = union(ParWrites,SeqWrites)

-- The following are the events that an external observer uses to
-- access locations in the model, or to force it to suspend activity
-- while the external system goes atomic.

ExtAccesses = Union({
             {|ivwrite.(-1).x | x <- inter(ExtWrites,ivnames)|},
             {|iveval.(-1).x | x <- inter(ExtReads,ivnames)|},
             {|bveval.(-1).x | x <- inter(ExtReads,bvnames)|},
             {|bvwrite.(-1).x | x <- inter(ExtWrites,bvnames)|},
             {|start_at.-1,end_at.-1 | ext_atomic|}
             })


channel PStart, PEnd

Signals'= union(Signals,{PStart,PEnd})

H(X) = (SQ.<Sig.PStart,X,Sig.PEnd>,({},{}))

UCM(X) = HierarchCompressedCompile(CSLeaf.H(X))(Union({ExtAccesses,Signals',ISignals,Errors}))
UCM'(X) = HierarchCompressedCompile(CSLeaf.H(X))(Union({ExtAccesses,Signals',ISignals,Errors,{|start_at,end_at|}}))
UCM''(X) = HierarchCompressedCompile(CSLeaf.(X,({},{})))(Union({ExtAccesses,Signals',ISignals,Errors,{|start_at,end_at|}}))

GRefReg0 = PStart -> GRefReg1(false)
          [] ivwrite.-1?x:inter(SeqWrites,ivnames)?_ -> GRefReg0
          [] bvwrite.-1?x:inter(SeqWrites,bvnames)?_ -> GRefReg0

GRefReg1(ineat) = PEnd -> GRefReg2
          [] ivwrite.-1?x:inter(ParWrites,ivnames)?_ -> GRefReg1(ineat)
          [] bvwrite.-1?x:inter(ParWrites,bvnames)?_ -> GRefReg1(ineat)
          [] iveval.-1?x:inter(ParReads,ivnames)?_ -> GRefReg1(ineat)
          [] bveval.-1?x:inter(ParReads,bvnames)?_ -> GRefReg1(ineat)
          [] ext_atomic and (not ineat)&start_at.-1 -> GRefReg1(true)
          [] ext_atomic and  ineat&end_at.-1 -> GRefReg1(false)
          [] ([] x:Union({Signals,ISignals}) @ x -> GRefReg1(ineat))
          [] ([] x:Errors @ x -> STOP)

GRefReg2 =  iveval.-1?x:inter(SeqReads,ivnames)?_ -> GRefReg2
          [] bveval.-1?x:inter(SeqReads,bvnames)?_ -> GRefReg2

RefRegSync = Union({{|ivwrite.-1,bvwrite.-1,iveval.-1,bveval.-1|},
                   Signals',ISignals, Errors,
                    {|start_at.-1,end_at.-1 | ext_atomic|}})

GenRefTest(X) = UCM(X)[|RefRegSync|]GRefReg0 

SRefReg0 = PStart -> SRefReg1
          [] ivwrite.-1?x:inter(SeqWrites,ivnames)?_ -> SRefReg0
          [] bvwrite.-1?x:inter(SeqWrites,bvnames)?_ -> SRefReg0

SRefReg1 = PEnd -> SRefReg2
          [] ([] x:Union({Signals,ISignals}) @ x -> SRefReg1)
          [] ([] x:Errors @ x -> STOP)

SRefReg2 =  iveval.-1?x:inter(SeqReads,ivnames)?_ -> SRefReg2
          [] bveval.-1?x:inter(SeqReads,bvnames)?_ -> SRefReg2

SeqRefTest(X) = UCM(X)[|RefRegSync|]SRefReg0 

ParRefReg(ineat) =  ivwrite.-1?x:inter(ParWrites,ivnames)?_ -> ParRefReg(ineat)
          [] bvwrite.-1?x:inter(ParWrites,bvnames)?_ -> ParRefReg(ineat)
          [] iveval.-1?x:inter(ParReads,ivnames)?_ -> ParRefReg(ineat)
          [] bveval.-1?x:inter(ParReads,bvnames)?_ -> ParRefReg(ineat)
          [] ext_atomic and (not ineat)&start_at.-1 -> ParRefReg(true)
          [] ext_atomic and  ineat&end_at.-1 -> ParRefReg(false)
          [] ([] x:Union({Signals,ISignals}) @ x -> ParRefReg(ineat))
          [] ([] x:Errors @ x -> STOP)

ParRefTest(C) = HierarchCompressedCompile(C) (Union({ExtAccesses,Signals',ISignals,Errors})) [|RefRegSync|]ParRefReg(false)

ParRefTestN(C) = HierarchCompressedCompileN(C) (Union({ExtAccesses,Signals',ISignals,Errors})) [|RefRegSync|]ParRefReg(false)


-- svacomp.csp

{- A compiler for shared variable programs for use as part
of SVA1.0.

Bill Roscoe, July 2009, amended Oct 2010

This is an updated version of the share2.csp program developed
by Bill Roscoe and David Hopkins.  It has extended functionality
including the use of compression capabilities of FDR automatically, proper
arrays (i.e. with non-constant indices) and explicit subtyping possibilities
for integer variables.  It is important to note that the program format expected
by this script is NOT consistent with share2.csp: hence the change of name.

Documentation of this file is provided by Chapters 18 and 19 of my 
book, "Understanding Concurrent Systems".  

There is a companion file, "svaref.csp", which supports the refinement model
described in the second of these chapters.

This file is intended to be used as an include file in a CSP script describing
the program to be analysed, itself most likely generated by the SVA tool.

The GUI of SVA is designed to generate files that, by including this one,
simulate shared variable programs.  The GUI, by running FDR in batch mode on
the such files, tests assertions within the input programs and, by processing
any counter-example generated by FDR, displays a representation of the
counter example partitioned by thread.

There are several major implementation differences with previous versions:

1. There are no longer separate processes for evaluating expressions: expression   evaluation is now done by the thread processes.  Thus we now have a process
   for each parallel thread and (with one strange exception) one for each
   variable or array component, plus possibly a process to maintain atomicity.
2. There is at present no option for all expressions to be evaluated atomically,   since this is not a very natural thing to have alongside our compression 
   strategy. 
3. All reads and writes by threads are now labelled with the index of the
   thread.  Furthermore signals must now be separate between threads.  This is
   to achieve a natural alphabetised parallel composition to aid compression.
4. Each variable and array component is now associated with a particular thread.
   The programmer may optionally assign some by hand.  If a variable
   is not assigned in this way, it is automatically assigned to the first
   process in numerical order that can apparently write to it. If there is   
   a "variable" or array component that is never written, separate read-only
   (one state) copies are associated with every thread that can read it.  
   The interactions of each thread with its local variables are then hidden.
5  We allow two different ways of compiling systems:
   (i)  The standard one (Compile) is applied to a list of processes
   (ii) There is also StructuredCompile, which can be used where a system
        is formed from groups of processes that it makes sense to compress
        on the way to creating the overall system.  A special data type is
        provided for this.
6. We provide both basic compilation functions and ones that apply some
   compression strategies.  The basic compression strategy is to individually
   compress the combination of each process with its local variables.  We
   also allow hierarchical compression based on the structured form described
   above.
7. The main role in achieving atomicity is delegated to the variables, which
   prevent any thread other than the one who has the atomic "token" reading or
   writing.
8. Monitors are renamed as "Overseers".
   The variables that an overseer observes are automatically calculated to be
   ALL its shared variables.  You can have  many overseers provided
   that they do not share variables with each other.
9. This file supports refsva.csp by enabling the values of variables to
   be read from and written to by an external ``thread'', index -1. Similarly,
   thread -1 may demand an atomic section.
10 We support Dirty locations, namely ones for which a write takes a
   definite time, during which any other access of this location causes
   misbehaviour.
-}


-- PART 1: basic declarations

 

transparent sbisim, diamond, normal

-- The following compression function seems to work well in conjunction
-- with this compiler.

sbdia(P) = sbisim(diamond(P))

compress = sbdia



{-

The following variables must be set in the input script.
Signals = {dummy} -- set of events
ISignals = {dummyi} -- set of channels whose types are sets of integers.

MinI = 0
MaxI = 20  -- limits of the integers that may be assigned or used as indices
           -- integer subtypes are subsets of {0..20}
stypes = <> -- pairs of the form (v,T) where v is an integer variable and
            -- T is a proper integer subtype for it (otherwise defaults to
            -- {MinT..MaxI})
ditype = {1..N}    -- the default index type for arrays
ditypes = <> -- exceptions to this: pairs of for form (v,T) where v is an
             -- array name and T is an integer subtype.
dctype = {MinI..MaxI} -- the default content type for integer arrays.
ctypes = <> -- pairs of for form (v,T) where v is an
             -- variable name and T is an integer subtype. default {MinI..MaxI}
catypes = <> -- exceptions to this: pairs of for form (v,T) where v is an
             -- array name and T is an integer subtype.

InitB = false  -- the default initialisation for boolean variables

init = (initi,initb) -- lists of initial values of variables and array
               -- components that a different from the default values defined
               -- above.  Both in format <(v,x)> where v is a variable and
               -- x is the initialisation.

mostprocs = 4   -- a number at least as large as the greatest number of threads
                -- in any process defined in the file.  It determines the size of
                -- some channel declarations.

ivnnums = {1,2,3} -- the indices of the integer variables used
iannums = {1,2,3} -- the indices of the integer arrays used
bvnnums = {1,2,3} -- the indices of the boolean variables used
bannums = {1,2,3} -- the indices of the boolean arrays used

-}

-- Part 1: Definitions of channels, names and types

-- The names of variables

datatype namestype = IV.Int | IA.Int.Int
                   | BV.Int | BA.Int.Int | NonVar

-- NonVar has a role in handling errors.

-- The ones actually used in this script

ianames = {IA.j | j <- ianums}
banames = {BA.j | j <- banums}

ivnames = union({IV.j | j <- ivnums},{IA.j.k | j <- ianums, k <- itype(IA.j)})
bvnames = union({BV.j | j <- bvnums},{BA.j.k | j <- banums, k <- itype(BA.j)})

vnames = union(ivnames,bvnames)

-- The ones used for reading and writing by external threads are assumed to
-- be defined as ExtReads and ExtWrites

-- The index type of an array:

itype(v) = let vts = <ty | (v',ty) <- itypes, v'==v> 
            within if vts==<> then ditype else head(vts)

-- The content type of an integer variable/array

ctype(IV.n) = let v = IV.n
              vts = <ty | (v',ty) <- ctypes, v'==v>
           within if vts == <> then {MinI..MaxI} else head(vts)

ctype(IA.n.m) = let a = IA.n
                vts = <ty | (v',ty) <- catypes, a==v'>
           within if vts == <> then dctype else head(vts)

--mostprocs is the upper bound on the number of processes used in a script

pnums =  {0..mostprocs-1}  -- the indices of the processes we create for the threads

pnums' = { -1..mostprocs-1} -- the indices of threads including -1 for external
                            -- accesses


-- The largest integer type used in programs

AllInts = {MinI..MaxI}

-- extended types to include an error value to handle run-time errors

datatype EInt = Ok.AllInts | NotOk
datatype ExtBool = BOk.Bool | BNotOk


-- These sets allow us to declare channels for reading and writing 
-- variables efficiently.

channel bveval,bvwrite:pnums'.bvnames.Bool
channel iveval,ivwrite:pnums'.ivnames.AllInts

-- The following channels control atomic execution.

-- The external thread is allowed to produce an atomic section
-- when ext_atomic is true.

pnums'' = if ext_atomic then pnums' else pnums

channel start_at, end_at:pnums''

-- The following compute the initial values of all variables etc.

initI(x,(ii,bi)) = let
                     xi = <v | (y,v) <- ii, 
                            y==x>
                   within
                     if xi==<> then 
                        setmin(ctype(x),MinI)  -- The least member of the content type
                     else
                     let <h>^_ = xi within h

setmin(T,k) = if member(k,T) then k else setmin(T,k+1) -- boring search


initB(x,(ii,bi)) = let
                     xi = <v | (y,v) <- bi, y==x>
                   within
                     if xi==<> then InitB else
                     let <h>^_ = xi within h


-- PART 2: Expressions and evaluating them.

-- Like variables, expressions are separated into boolean and integer types.  There is
-- no formal separation between the different integer sub-ranges: these subranges are
-- checked on assignment and array indexing.

-- The following definitions support the evaluation of simple integer and
-- boolean data types in a contest where each variable and expression has its
-- own process, and values are communicated between them.

datatype BinIOps = Plus | Times | Minus | Div | Mod | Max | Min
datatype UIOps = Uminus

datatype IExpr =  IVar.ivnames |
                  IArc.(ianames,IExpr) |
                  Const.{MinI..MaxI} |
                  BIOp.BinIOps.IExpr.IExpr |
                  UIOp.UIOps.IExpr |
                  ErrorI

-- The following function decides if an integer expression is formally constant.

CEx(IVar._) = false
CEx(IArc._) = false
CEx(Const._) = true
CEx(ErrorI) = true
CEx(BIOp.X.ea.eb) = CEx(ea) and CEx(eb)
CEx(UIOp.X.e) = CEx(e)

-- The following are the corresponding definitions for the boolean type.

datatype BinBOps = And | Or | Xor
datatype CompOps = Eq | Neq | Gt | Ge | Lt | Le

datatype BExpr = BVar.bvnames |
                 BArc.(banames,IExpr) |
                 True |
                 False |
                 Not.BExpr |
                 BBOp.BinBOps.BExpr.BExpr |
                 CompOp.CompOps.IExpr.IExpr |
                 ErrorB

CBEx(BVar._) = false
CBEx(BArc._) = false
CBEx(True) = true
CBEx(False) = true
CBEx(ErrorB) = true
CBEx(Not.e) = CBEx(e)
CBEx(BBOp._.ea.eb) = CBEx(ea) and CBEx(eb)
CBEx(CompOp._.ea.eb) = CEx(ea) and CEx(eb)

-- The following functions decide which is the first variable to fetch first 
-- when evaluating a non-constant expression.

datatype fetch = Error | NoF | ISV.ivnames | BSV.bvnames | ErrorX

-- Note that the structure of expressions means that integer variables can appear within
-- boolean expressions, but not vice-versa.

ffetchi(IVar.n) = ISV.n
ffetchi(IArc.(v,e)) = let f = ffetchi(e) 
                 within
                 (if f == NoF then
                    (let k=evaluatei(e) within
                       if ok(k) then
                         let n=num(k) within
                           ErrorX
                       else ErrorX)
                  else f)

ffetchi(Const.k) = NoF

ffetchi(BIOp._.ea.eb) = let ffe = ffetchi(ea) within
                     if ffe==NoF then ffetchi(eb)
                                 else ffe

ffetchi(UIOp._.e) = ffetchi(e)

ffetchi(ErrorI) = NoF

-- NoF means that no fetch is necessary: the expression is constant.

ffetchb(BVar.n) = BSV.n
ffetchb(BArc.(v,e)) = let f = ffetchi(e) within
                 if f == NoF then
                    (let k=evaluatei(e) within
                       if ok(k) then
                         let n=num(k) within
                           (if member(n,itype(v)) then BSV.v.n else ErrorX)
                       else ErrorX)
                  else f
ffetchb(True) = NoF
ffetchb(False) = NoF

ffetchb(Not.e) = ffetchb(e)

ffetchb(BBOp._.ea.eb) = let ffe = ffetchb(ea) within
                     if ffe==NoF then ffetchb(eb)
                                 else ffe

ffetchb(CompOp._.ea.eb) = ffetchi(BIOp.Plus.ea.eb)

ffetchb(ErrorB) = NoF

-- The following pair of channels represent error events generated
-- respectively by threads and integer variable processes.
-- They represent the following types of run-time errors:
-- array index out of range
-- attempt to assign an out of range value to an integer variable 
-- division or MOD by 0

-- Note that the main types also contain error values, which ultimately
-- propagate to the generation of one of these in execution.
 

channel error:pnums
channel verror:union(ivnames,bvnames)

Errors = {|error,verror|}

-- The following function evaluates the integer expression e, for process index
-- j, with continuation P: a function from integers to the process that follows
-- on from the expression evaluation whose argument is the value calculated for
-- e.  To evaluate a non-constant expression it is necessary to fetch the
-- values of one or more variables.

IExpEval(e,P,j) = let 
                   IXEF(NoF) =
                    let k=evaluatei(e) within
                       if ok(k) and num(k)>=MinI and num(k) <=MaxI then 
                                 P(num(k))
                          else error.j -> STOP
                 IXEF(ISV.x) = iveval.j.x?v -> IExpEval(subsi(x,Const.v,e),P,j)
                 within IXEF(ffetchi(e))

-- The following evaluates an expression as a Left Value: a location that
-- can be written/assigned to.  Its argument P expects such a location as
-- its input.
                        
ILvEval(IVar.v,P,j) = P(v)

ILvEval(IArc.(v,e),P,j) = let 
                IXEF(NoF) =
                    let k=evaluatei(e) within
                       if ok(k) then
                                let n=num(k) within
                                   if member(n,itype(v)) then P(v.n)
                                   else error.j -> STOP
                          else error.j -> STOP
                IXEF(ISV.w) = iveval.j.w?x -> ILvEval(IArc.(v,subsi(w,x,e)),P,j)
               within
                   IXEF(ffetchi(e))

-- The main mechanism of expression evaluation is substitution of a fetched value
-- (represented as a constant) for a variable.

subsi(x,v,ErrorI) = ErrorI
subsi(x,v,IVar.y) = (if x==y then v else IVar.y)
subsi(x,v,IArc.(y,e)) = let e'=subsi(x,v,e) 
                      within
                        if CEx(e') then let k=evaluatei(e')
                                        within
                                        if not(ok(k)) then ErrorI
                                        else let n=num(k) within
                                          (if not(member(n,itype(y))) then ErrorI
                                           else IVar.y.n)
                                   else IArc.(y,e')
subsi(x,v,Const.c) = Const.c
subsi(x,v,BIOp.X.a.b) = BIOp.X.subsi(x,v,a).subsi(x,v,b)
subsi(x,v,UIOp.X.a) = UIOp.X.subsi(x,v,a)


num(Ok.n) = n
ok(Ok._) = true
ok(NotOk) = false

-- The following function works out the actual value -- which may be error --
-- of a constant expression.

evaluatei(ErrorI) = NotOk
evaluatei(Const.c) = Ok.c
evaluatei(BIOp.X.a.b) = let
                        ea = evaluatei(a)
                        eb = evaluatei(b)
                          res(Plus) = num(ea) + num(eb) 
                          res(Minus) = num(ea) - num(eb) 
                          res(Times) = num(ea) * num(eb) 
                          res(Div) = num(ea) / num(eb) 
                          res(Mod) = num(ea) % num(eb) 
                          res(Max) = let av=num(ea) 
                                         bv= num(eb) 
                                     within
                                       if av>bv then av else bv
                          res(Min) = let av=num(ea) 
                                         bv= num(eb) 
                                     within
                                       if av<bv then av else bv
                        within
                          if ok(ea) and ok(eb) and 
                              not(member(X,{Div,Mod}) and eb==(Ok.0))
                              then Ok.res(X) 
                              else NotOk
                           
evaluatei(UIOp.X.a) = let
                        ea = evaluatei(a)
                        res(UMinus) = 0-num(ea) 
                      within
                          if ok(ea) then Ok.res(X) else NotOk

-- The following do the same for boolean expressions: first the substitution
-- of a boolean value for a boolean variable

subsb(x,v,ErrorB) = ErrorB
subsb(x,v,True) = True
subsb(x,v,False) = False
subsb(x,true,BVar.y) = if y==x then True else BVar.y
subsb(x,false,BVar.y) = if y==x then False else BVar.y
subsb(x,v,BArc.(y,e)) = if CEx(e) then let k=evaluatei(e)
                                        within
                                        if not(ok(k)) then ErrorB
                                        else let n=num(k) within
                                          (if not(member(n,itype(y))) then ErrorB
                                           else BVar.y.n)
                                   else BArc.(y,e)
subsb(x,v,Not.e) = Not.subsb(x,v,e)
subsb(x,v,BBOp.X.e.f) = BBOp.X.subsb(x,v,e).subsb(x,v,f)
subsb(x,v,CompOp.X.a.b) = CompOp.X.a.b

-- And secondly the substitution for an integer variable within a boolean
-- expression (the reverse does not happen in our syntax)

subsbi(x,v,ErrorB) = ErrorB
subsbi(x,v,True) = True
subsbi(x,v,False) = False
subsbi(x,v,BVar.y) = BVar.y
subsbi(x,v,BArc.(y,e)) = let e'=subsi(x,v,e) 
                       within
                        if CEx(e') then let k=evaluatei(e')
                                        within
                                        if not(ok(k)) then ErrorB
                                        else let n=num(k) within
                                         (if not(member(n,itype(y))) then ErrorB
                                          else BVar.y.n)
                                   else BArc.(y,e')
subsbi(x,v,Not.e) = Not.subsbi(x,v,e)
subsbi(x,v,BBOp.X.e.f) = BBOp.X.subsbi(x,v,e).subsbi(x,v,f)
subsbi(x,v,CompOp.X.a.b) = CompOp.X.subsi(x,v,a).subsi(x,v,b)

-- The evaluation functions for boolean expressions

BExpEval(e,P,j) = let 
                   BXEF(NoF) =
                    let k=evaluateb(e) within
                       if bok(k) then P(bval(k))
                          else error.j -> STOP
               BXEF(ISV.v) = iveval.j.v?x -> BExpEval(subsbi(v,x,e),P,j)
               BXEF(BSV.v) = bveval.j.v?x -> BExpEval(subsb(v,x,e),P,j)
               within
                   BXEF(ffetchb(e))


BLvEval(BVar.v,P,j) = P(v)

BLvEval(BArc.(v,e),P,j) = let 
                   IXEF(NoF) =
                    let k=evaluatei(e) within
                       if ok(k) then
                                let n=num(k) within
                                   if member(n,itype(v)) then P(v.n)
                                   else error.j -> STOP
                          else error.j -> STOP
                IXEF(ISV.w) = iveval.j.w?x -> BLvEval(BArc.(v,subsi(w,x,e)),P,j)
               within
                   IXEF(ffetchi(e))

bval(BOk.b) = b
bok(BOk._) = true
bok(BNotOk) = false

evaluateb(True) = BOk.true
evaluateb(False) = BOk.false
evaluateb(ErrorB) = BNotOk
evaluateb(Not.a) = let ea = evaluateb(a) within
                   if bok(ea) then BOk.(not(bval(ea)))
                      else BNotOk
evaluateb(BBOp.X.a.b) = let
                      ea = evaluateb(a) 
                      eb = evaluateb(b) 
                     within
                      if bok(ea) and bok(eb) then
                        (if X==And then BOk.(bval(ea) and bval(eb))
                        else if X==Or then BOk.(bval(ea) or bval(eb))
                        else if X==Xor then BOk.not(bval(ea) or bval(eb))
                        else BNotOk)
                      else BNotOk
evaluateb(CompOp.X.a.b) = let
                        ea = evaluatei(a)
                        eb = evaluatei(b)
                      within
                        if ok(ea) and ok(eb) then 
                        (if X==Eq then BOk.(num(ea)==num(eb))
                         else if X==Neq then BOk.(num(ea)!=num(eb))
                         else if X==Ge then BOk.(num(ea)>=num(eb))
                         else if X==Gt then BOk.(num(ea)>num(eb))
                         else if X==Le then BOk.(num(ea)<=num(eb))
                         else if X== Lt then BOk.(num(ea)<num(eb))
                         else BNotOk)
                        else BNotOk



-- PART 3: Variables

-- There are four basic types of variable: integer or boolean,
-- and encompassing atomic behaviour or not.

IVAR(x,v) = 
          let 
	      t = ctype(x) 
              wnames = if member(x,ExtWrites) then pnums' else pnums
              rnames = if member(x,ExtReads) then pnums' else pnums
              Dirty(i) = iveval?_:rnames!x?y:t -> Dirty(i)
                      [] ivwrite?j:wnames!x?_ -> (if j==i then SKIP 
                                                   else verror.x -> STOP)
              within
            (iveval?_:rnames!x!v -> IVAR(x,v)
         [] ivwrite?jj:wnames!x?w -> if member(x,DirtyVars) then
                                (Dirty(jj);IVAR(x,w))
                                else IVAR(x,w))

BVAR(x,v) = 
           let Dirty(i) = bveval?_!x?_ -> Dirty(i)
                        [] bvwrite?j!x?_ -> (if j==i then SKIP
                                                  else verror.x -> STOP)
              wnames = if member(x,ExtWrites) then pnums' else pnums
              rnames = if member(x,ExtReads) then pnums' else pnums
            within
            bveval?_:rnames!x!v -> BVAR(x,v)
         [] bvwrite?jj:wnames!x?w -> if member(x,DirtyVars) then
                                 (Dirty(jj);BVAR(x,w))
                              else BVAR(x,w)


-- An atomic-enabled variable only allows one process to read or write it during
-- the atomic period.

BVAR_at(x,v) = 
           let Dirty(i) = bveval?_!x?_ -> Dirty(i)
                        [] bvwrite?j!x?_ -> (if i==j then SKIP
                                                     else verror.x -> STOP)
                        [] start_at?j ->  Dirty_at(i,j)
               Dirty_at(i,j) = end_at.j -> Dirty(i)
                               [] member(j,rnames) & bveval.j!x?_ 
                                               -> Dirty_at(i,j)
                               [] member(j,wnames) & bvwrite.j!x?_  
                                               -> verror.x -> STOP
               wnames = if member(x,ExtWrites) then pnums' else pnums
               rnames = if member(x,ExtReads) then pnums' else pnums
            within
            bveval?_:rnames!x!v -> BVAR_at(x,v)
         [] bvwrite?jj:wnames!x?w ->(if member(x,DirtyVars) then Dirty(jj);BVAR_at(x,w)
                              else BVAR_at(x,w))
         [] start_at?j:pnums'' -> BVAR_inat(j,x,v)

IVAR_at(x,v) = 
          let 
	      t = ctype(x) 
              Dirty(i) = iveval?_:rnames!x?y:t -> Dirty(i)
                      [] ivwrite?j:wnames!x?_ -> (if i==j then SKIP 
                                                          else verror.x -> STOP)
                      [] start_at?j ->  Dirty_at(i,j)
              Dirty_at(i,j) = end_at.j -> Dirty(i)
                              [] member(j,rnames) & iveval.j!x?_ -> 
                                                     Dirty_at(i,j)
                              [] member(j,wnames) & ivwrite.j!x?_ -> 
                                                     verror.x -> STOP
               wnames = if member(x,ExtWrites) then pnums' else pnums
               rnames = if member(x,ExtReads) then pnums' else pnums
          within
            iveval?_:rnames!x!v -> IVAR_at(x,v)
         [] ivwrite?jj:wnames!x?w ->
              (if member(x,DirtyVars) then Dirty(jj);IVAR_at(x,w)
                                      else IVAR_at(x,w))
      
         [] start_at?j:pnums'' -> IVAR_inat(j,x,v)

BVAR_inat(j,x,v) = 
            bveval.j!x!v -> BVAR_inat(j,x,v)
         [] (bvwrite.j!x?w -> if member(x,DirtyVars) then bvwrite.j.x?_ -> BVAR_inat(j,x,w)
                             else BVAR_inat(j,x,w))
         [] end_at.j -> BVAR_at(x,v)

IVAR_inat(j,x,v) = 
            iveval.j!x!v -> IVAR_inat(j,x,v)
         [] (ivwrite.j!x?w -> if member(x,DirtyVars) then ivwrite.j.x?_ -> IVAR_inat(j,x,w)
                                 else IVAR_inat(j,x,w))
         [] end_at.j -> IVAR_at(x,v)

-- The following non-writable variables are used for representing variables
-- that are never written.

CBV(j,x,v) = bveval.j!x!v -> CBV(j,x,v)
CBV_at'(j,x,v) = bveval.j!x!v -> CBV_at'(j,x,v)

RUN(X) = [] x:X @ x -> RUN(X)

-- There is no need to restrict how such variables are treated in atomic
-- execution.

CBV_at(j,x,v) = CBV_at'(j,x,v) ||| RUN({|start_at,end_at|})

CIV(j,x,v) = iveval.j!x!v -> CIV(j,x,v)
CIV_at'(j,x,v) = iveval.j!x!v -> CIV_at'(j,x,v)

CIV_at(j,x,v) = CIV_at'(j,x,v) ||| RUN({|start_at,end_at|})



-- PART 4: Commands

-- The following is the datatype representing the syntax of thread processes.

datatype Cmd = Skip |
               Sq.(Cmd,Cmd) | 
               SQ.Seq(Cmd) |
               Iter.Cmd | While.(BExpr,Cmd) | 
               Cond.(BExpr,Cmd,Cmd) | 
               Iassign.(IExpr,IExpr) | Bassign.(BExpr,BExpr)| 
               Sig.Signals | ISig.(ISignals,IExpr) |
               Atomic.Cmd  | ErrorC


bassign(el,er) = Bassign.(el,er)
iassign(el,er) = Iassign.(el,er)



-- The following function removes nested Atomic constructs, which
-- are unnecessary.

One_at2((P,lvs)) = (One_at(P),lvs)

One_at(Sq.(p,q)) = Sq.(One_at(p),One_at(q))
One_at(SQ.ps) = SQ.<One_at(p) | p <- ps>
One_at(Iter.p) = Iter.(One_at(p))
One_at(Cond.(b,p,q)) = Cond.(b,One_at(p),One_at(q))
One_at(Atomic.p) = Atomic.(No_at(p))
One_at(p) = p
No_at(Sq.(p,q)) = Sq.(No_at(p),No_at(q))
No_at(SQ.ps) = SQ.<No_at(p) | p <- ps>
No_at(Iter.p) = Iter.(No_at(p))
No_at(Cond.(b,p,q)) = Cond.(b,No_at(p),No_at(q))
No_at(Atomic.p) = No_at(p)
No_at(p) = p

-- And the following one reduces any constant expression in a program.  This
-- is important for array indices, since being constant means we can attribute
-- variables to components accurately.

ConstC(j,Sq.(p,q)) = Sq.(ConstC(j,p),ConstC(j,q))
ConstC(j,SQ.ps) = SQ.<ConstC(j,p) | p <- ps>
ConstC(j,Iter.p) = Iter.(ConstC(j,p))
ConstC(j,Cond.(b,p,q)) = if CBEx(b) then
                          let v=evaluateb(b) within
                          if bok(v) then 
                             let bv = bval(v) within
                                 if bv then ConstC(j,p) else ConstC(j,q)
                                 else ErrorC
                          else Cond.(ConstB(b),ConstC(j,p),ConstC(j,q))
ConstC(j,While.(b,p)) = if CBEx(b) then
                          let v=evaluateb(b) within
                          if bok(v) then 
                             let bv = bval(v) within
                                 if bv then Iter.ConstC(j,p) else Skip
                                 else ErrorC
                          else While.(ConstB(b),ConstC(j,p))

ConstC(j,Atomic.p) = Atomic.ConstC(j,p)
ConstC(j,Iassign.(ea,eb)) = Iassign.(ConstI(ea),ConstI(eb))
ConstC(j,Bassign.(ea,eb)) = Bassign.(ConstB(ea),ConstB(eb))
ConstC(j,ISig.(a,e)) = ISig.(a,ConstI(e))
ConstC(j,p) = p

ConstI(IVar.v) = IVar.v
ConstI(IArc.(v,e)) = let e' = ConstI(e)
                      Res(ErrorI) = ErrorI
                      Res(Const.n) = if member(n,itype(v)) then IVar.(v.n)
                                                else ErrorI
                      Res(x) = IArc.(v,e')
                     within
                      Res(e')
ConstI(Const.n) = Const.n
ConstI(BIOp.X.ea.eb) = let ea'= ConstI(ea)
                           eb'= ConstI(eb)
                           Res(_,ErrorI,_) = ErrorI
                           Res(_,_,ErrorI) = ErrorI
                           Res(Plus,Const.n,Const.m) = Const.(n+m)
                           Res(Minus,Const.n,Const.m) = Const.(n-m)
                           Res(Times,Const.n,Const.m) = Const.(n*m)
                           Res(Div,Const.n,Const.m) = if m!=0 then Const.(n/m)
                                                              else ErrorI
                           Res(Mod,Const.n,Const.m) = if m!=0 then Const.(n%m)
                                                              else ErrorI
                           Res(Max,Const.n,Const.m) = if n>m then Const.n 
                                                             else Const.m
                           Res(Min,Const.n,Const.m) = if n<m then Const.n 
                                                             else Const.m
                           Res(Y,ex,ey) = BIOp.Y.ex.ey
                           within Res(X,ea',eb')
                        
                        
ConstI(UIOp.X.ea) = let ea'= ConstI(ea)
                        Res(_,ErrorI) = ErrorI
                        Res(UMinus,Const.n) = Const.(0-n)
                        Res(Y,ex) = UIOp.Y.ex
                      within Res(X,ea')
                        

ConstB(ErrorB) = ErrorB
ConstB(BVar.v) = BVar.v
ConstB(BArc.(v,e)) = let e' = ConstI(e)
                      Res(ErrorI) = ErrorB
                      Res(Const.n) = if member(n,itype(v)) then BVar.v.n
                                                else ErrorB
                      Res(x) = BArc.(v,e')
                     within
                      Res(e')
ConstB(True) = True
ConstB(False) = False
ConstB(ErrorB) = ErrorB
ConstB(False) = False
ConstB(BBOp.X.ea.eb) = let ea'=ConstB(ea)
                          eb'=ConstB(eb)
                          Res(ErrorB,_)=ErrorB
                          Res(_,ErrorB)=ErrorB
                          Res(ex,ey) = BBOp.X.ex.ey
                       within Res(ea',eb')

ConstB(Not.ea) = let ea'=ConstB(ea)
                          Res(ErrorB)=ErrorB
                          Res(ex) = Not.ex
                       within Res(ea)
ConstB(CompOp.X.ea.eb) = let ea'=ConstI(ea)
                          eb'=ConstI(eb)
                          Res(ErrorI,_)=ErrorB
                          Res(_,ErrorI)=ErrorB
                          Res(ex,ey) = CompOp.X.ex.ey
                       within Res(ea',eb')


ConstIV(e) = let ie = ConstI(e)
                 xt(IVar.IV.v) = IV.v
                 xt(IVar.IA.v) = IA.v
                 xt(_) = NonVar
             within xt(ie)

ConstBV(e) = let be = ConstB(e)
                 xt(BVar.BV.v) = BV.v
                 xt(BVar.BA.v) = BA.v
                 xt(_) = NonVar
             within xt(be)

ConstR(j,(C,(flivs,flbvs))) = (ConstC(j,C),
                            diff(union({ConstIV(e) | e <- flivs},
                                       {ConstBV(e) | e <- flbvs}),
                                 {NonVar}))



-- The following function converts a list of threads into a list of
-- CSP processes that simulate each thread and its local variables.

CompileListA(C',OvSrs) = let
               Cprs = <ConstR(j,One_at2(nth(C',j))) | j <- <0..(#C')-1>>
   within
   Analyse(Cprs,OvSrs)

--   (IW,IR,BW,BR,LIV,LBV,ROI,ROB,Alpha,Alpha_at,LI,UseAtomic,SEv) = CompileList()
CompileList(C',OvSrs) = let
               Cprs = <ConstR(j,One_at2(nth(C',j))) | j <- <0..(#C')-1>>
   (IW,IR,BW,BR,LIV,LBV,ROI,ROB,Alpha,Alpha_at,LI,UseAtomic,SEv) = Analyse(Cprs,OvSrs)
               C = <P | (P,_) <- Cprs>
               IVs(j) = union(IW(j),IR(j))
               BVs(j) = union(BW(j),BR(j))
               np = #C
               pnumsl = {0..np-1}
               pnumsl' = { -1..np-1}
               pnumsl'' = if ext_atomic then pnumsl' else pnums
               IVR(x) = IVAR(x,initI(x,init))
                     [|Union({{|ivwrite.j.x  | j <- pnumsl, not(member(x,IW(j)))|},
                           {|iveval.j.x | j <- pnumsl, not(member(x,IR(j)))|},
                           {|iveval.i,ivwrite.i | i <- diff(pnums,pnumsl)|},
                           {|iveval.-1.x | not(member(x,ExtReads))|},
                           {|ivwrite.-1.x | not(member(x,ExtWrites))|},
                           {ivwrite.-1.x.v | v <- diff(AllInts,ctype(x))}
                            })|]
                     STOP
               -- A local ordinary integer variable.  Blocking off impossible
               -- reads and writes to aid compression functions.
               BVR(x) = BVAR(x,initB(x,init))
                     [|Union({{|bvwrite.j.x  | j <- pnumsl, not(member(x,BW(j)))|},
                           {|bveval.j.x | j <- pnumsl, not(member(x,BR(j)))|},
                           {|bveval.i,bvwrite.i | i <- diff(pnums,pnumsl)|},
                           {|bveval.-1.x | not(member(x,ExtReads))|},
                           {|bvwrite.-1.x | not(member(x,ExtWrites))|}
                            })|]
                     STOP
               MPV(j) = if member(j,OvSrs) then OvSrPlusVars(j)
                                          else MainProcPlusVars(j)
               MainProcPlusVars(j) = 
                       let VS = union(LIV(j),LBV(j))
                           ROS = union(ROI(j),ROB(j))
                           AVs = union(VS,ROS)
                           V(x) = if member(x,LIV(j)) then IVR(x)
                                  else if member(x,LBV(j)) then BVR(x)
                                  else if member(x,ROI(j)) then 
                                        CIV(j,x,initI(x,init))
                                  else
                                        CBV(j,x,initB(x,init))
                       within
                       if empty(AVs) then 
                              MainProc(nth(C,j),j)
                       else
                          (MainProc(nth(C,j),j)[|LI(j)|]
                              (||| x:AVs @ V(x))
                                   )
               OvSrPlusVars(j) =  -- an overseer process
                       let VS = union(LIV(j),LBV(j))
                           ROS = union(ROI(j),ROB(j))
                           AVs = union(VS,ROS)
                           V(x) = if member(x,ivnames)  then IVR(x)
                                                        else BVR(x)
    
                       within
                       (OvSrRun(MainProc(nth(C,j),j),j,IVs(j),BVs(j),pnumsl')
                        [|LI(j)|]
                              if empty(AVs) then STOP
                              else (||| x:AVs @ V(x))
                                   )
               -- The same concepts with atomicity present.
               OvSrPlusVars_at(j) =   -- a monitor process for systems with atomic sections
                       let AVS = union(LIV(j),LBV(j))
                           LVS = diff(VS,Union({LIV(k),LBV(k) | 
                                             k <- pnums, k!=j}))
                           V(x) = if member(x,ivnames) 
                                   then IVR_at(x)
                                   else BVR_at(x)
                           LI_at = Union({LI(j),{|start_at,end_at|},SEv(j)})
                       within
                      (OvSrRun_at(MainProc(nth(C,j),j),j,IVs(j),BVs(j),pnumsl')
                         [|LI_at|]
                            (if empty(AVS) then STOP else
                              ([|{|start_at,end_at|}|] x:AVS @ V(x)))
                              -- No  At_Reg because monitors don't have atomic sections
                                   )

               IVR_at(x) = IVAR_at(x,initI(x,init))
                     [|Union({{|ivwrite.j.x  | j <- pnumsl, not(member(x,IW(j)))|},
                           {|iveval.j.x | j <- pnumsl, not(member(x,IR(j)))|},
                           {|iveval.i,ivwrite.i | i <- diff(pnums,pnumsl)|},
                           {|iveval.-1.x | not(member(x,ExtReads))|},
                           {|ivwrite.-1.x | not(member(x,ExtWrites))|},
                           {ivwrite.-1.x.v | v <- diff(AllInts,ctype(x))}
                            })|]
                     STOP
               BVR_at(x) = BVAR_at(x,initB(x,init))
                     [|Union({{|bvwrite.j.x  | j <- pnumsl, not(member(x,BW(j)))|},
                           {|bveval.j.x | j <- pnumsl, not(member(x,BR(j)))|},
                           {|bveval.i,bvwrite.i | i <- diff(pnums,pnumsl)|},
                           {|bveval.-1.x | not(member(x,ExtReads))|},
                           {|bvwrite.-1.x | not(member(x,ExtWrites))|}
                            })|]
                     STOP
               MainProcPlusVars_at(j) = 
                       let VS = union(LIV(j),LBV(j))
                           ROS = union(ROI(j),ROB(j))
                           LI_at = Union({LI(j),{|start_at,end_at|},SEv(j)})
                           AVs = union(VS,ROS)
                           V(x) = if member(x,LIV(j)) then IVR_at(x)
                                  else if member(x,LBV(j)) then BVR_at(x)
                                  else if member(x,ROI(j)) then 
                                        CIV_at(j,x,initI(x,init))
                                  else
                                        CBV_at(j,x,initB(x,init))
                       within
                       if empty(AVs) then 
                        (MainProc(nth(C,j),j)
                        [|union({start_at.j,end_at.j},SEv(j))|]At_reg(j))
                       else
                       ((MainProc(nth(C,j),j)
                        [|union({start_at.j,end_at.j},SEv(j))|]At_reg(j))
                        [|union({|start_at,end_at|},LI(j))|]
                              ([|{|start_at,end_at|}|] x:AVs @ V(x))
                                   )
                   At_reg(i) = start_at.i -> At_reg'(i)
                            [] start_at?j:{k | k <- pnumsl'', k !=i} 
                                   -> end_at!j -> At_reg(i)
                            [] ([] x:SEv(i) @ x -> At_reg(i))
                   At_reg'(i) = end_at.i -> At_reg(i)
                            [] ([] x:SEv(i) @ x -> At_reg'(i))
               MPV_at(j) = if member(j,OvSrs) then OvSrPlusVars_at(j)
                                          else MainProcPlusVars_at(j)

               MP = if UseAtomic>0 or ext_atomic then  
                        <(MPV_at(j),Alpha_at(j)) | j <- <0..np-1>>
                    else
                        <(MPV(j),Alpha(j)) | j <- <0..np-1>>
             within
               MP



-- The following function applies the basic compression strategy to the
-- list of processes produced by the above.  All reads and writes are hidden,
-- leaving only signals visible.  This automatically leads to the hiding and
-- therefore (hopefully) compression of interactions between a thread and
-- its local variables, namely the LI(j)

CompressedCompile((CR,COS))(AS) = let C = CR^COS
                                 OvSrs = {#CR..#CR+#COS-1}
                             within
LeafCompress(compress)(CompileList(C,OvSrs))(diff(Events,AS))

-- The same with no compression.

Compile((CR,COS)) =  let C = CR^COS
                     OvSrs = {#CR..#CR+#COS-1}
                     within
           ListPar(CompileList(C,OvSrs))\(diff(Events,AS))



-- Part 5. Analysis of networks

-- The compilation functions above relied on other functions to compute sets of
-- variables, alphabets etc.

-- The following function analyses a list of processes and returns
-- various pieces of data that allow the alphabets of processes, the sets of
-- local variables and other things to be calculated for the construction of
-- the simulation/compilation.


Analyse(C,OvSrs) = let Ps = <Analyse1(P) | (P,_) <- C> 
                 OvSrIVs = Union({IW(j),IR(j) | j <- OvSrs})
                 OvSrBVs = Union({BW(j),BR(j) | j <- OvSrs})
                 OvSrVs = union(OvSrIVs,OvSrBVs)
                 DLVs = <dlv | (_,dlv) <- C>
                 DLIV(i) = inter(ivnames,nth(DLVs,i))
                 DLBV(i) = inter(bvnames,nth(DLVs,i))
                 PriVars = Union(set(DLVs))
                 UnAlSL = diff(union(ExtReads,ExtWrites),WV)
                 np = #C
                 pnumsl = {0..np-1}
                 pnumsl' = { -1..np-1}
                 pnumsl'' = if ext_atomic then pnums' else pnumsl
                 IW(j) = if j==(-1) then inter(ivnames,ExtWrites)
                         else
                           let (x,y,z,t,_,_)=nth(Ps,j)
                         within x
                 IW'(j) = diff(IW(j),PriVars)
                 IR(j) = if j==(-1) then inter(ivnames,ExtReads)
                         else
                         let (x,y,z,t,_,_)=nth(Ps,j)
                         within y
                 BW(j) = if j==(-1) then inter(bvnames,ExtWrites)
                         else
                         let (x,y,z,t,_,_)=nth(Ps,j)
                         within z
                 BW'(j) = diff(BW(j),PriVars)
                 BR(j) = if j==(-1) then inter(bvnames,ExtReads)
                         else
                         let (x,y,z,t,_,_)=nth(Ps,j)
                         within t
                 IVs(j) = union(IR(j),IW(j))
                 BVs(j) = union(BR(j),BW(j))
                 ua = listmax(<x | (_,_,_,_,x,_) <- Ps>)
                 SEv(j) = let (_,_,_,_,_,se) = nth(Ps,j)
                          within union(se,{error.j})
                 WV = Union({ PriVars,
                             Union({IW(j),BW(j) | j <- pnumsl})})
                 WV' = union(WV,UnAlSL)
                 LIV(j) =  if member(j,OvSrs) then IVs(j) -- overseer takes all its vars
                           else diff(Union({
                               union(DLIV(j),
                               diff(IW'(j),
                               Union({LIV(i) | i <- {0..j-1}}))),
                          if j==0 then inter(UnAlSL,ivnames) else {}
                            }),OvSrIVs) 
                 LBV(j) = if member(j,OvSrs) then BVs(j) -- overseer takes all its vars
                          else diff(Union({
                               union(DLBV(j),
                               diff(BW'(j),
                               Union({LBV(i) | i <- {0..j-1}}))),
                           if j==0 then inter(UnAlSL,bvnames) else {}}),OvSrBVs)
                 ROI(j) = diff(IR(j),WV')
                 ROB(j) = diff(BR(j),WV')
                 LI(j) =  if member(j,OvSrs) then -- overseer controls access to all is vars
                           Union({
                           {|iveval.i.v,ivwrite.i.v | i <- pnums', v <- LIV(j)|},
                           {|bveval.i.v,bvwrite.i.v | i <- pnums', v <- LBV(j)|}})
                           else
                           Union({
                           {|iveval.j.v,ivwrite.j.v | v <- LIV(j)|},
                           {|bveval.j.v,bvwrite.j.v | v <- LBV(j)|},
                           {|iveval.j.v | v <- ROI(j)|},
                           {|bveval.j.v | v <- ROB(j)|}
                              })

                 Alpha(j) = Union({
                           SEv(j),
                           {verror.v | v <- LIV(j)},
                           {error.j},
                           {|iveval.j, ivwrite.j,bveval.j,bvwrite.j|},
                    {|iveval.k.v | v <- LIV(j),k <- pnumsl', member(v,union(IR(k),{ -1}))|},
                    {|bveval.k.v | v <- LBV(j),k <- pnumsl', member(v,union(BR(k),{ -1}))|},
                    {|ivwrite.k.v | v <- LIV(j),k <- pnumsl', member(v,union(IW(k),{ -1}))|},
                    {|bvwrite.k.v | v <- LBV(j),k <- pnumsl', member(v,union(BW(k),{ -1}))|},
                    {|iveval.k.v | v <- IVs(j),k <- pnumsl',member(j,OvSrs) |},
                    {|bveval.k.v | v <- BVs(j),k <- pnumsl', member(j,OvSrs)|},
                    {|ivwrite.k.v | v <- IVs(j),k <- pnumsl', member(j,OvSrs)|},
                    {|bvwrite.k.v | v <- BVs(j),k <- pnumsl', member(j,OvSrs)|}
                                  })
                 Alpha_at(j) = Union({
                             Alpha(j),
                             {|start_at,end_at|}})
                               
                 within
                    (IW,IR,BW,BR,LIV,LBV,ROI,ROB,Alpha,Alpha_at,LI,ua,SEv) 


{- Here:

IW is a function of thread index returning the writable integer variables
   (including array components) for the given thread
IR is a function of thread index returning the readable integer variables
BW is a function of thread index returning the writable boolean variables
BR is a function of thread index returning the readable boolean variables

LIV and LBV return the variables that are assigned as local to the thread
   apart from
ROI and ROB which are the never-written (necessarily by anyone) local variables.
Variables are assigned to processes with the following priorities:
1. All variables of a monitor are assigned to it [so that it can definitely see
   all writes to such variables.
2. All variables that the user has requested to be associated to a thread.
3. All variables that this thread can write to but not prior one can
4. All other variables that this thread can read from.

Alpha and Alpha_at return the alphabets of the combinations of thread and local
   variables respectively where atomicity is not/is part of the simulation.

LI is a function indicating what events can be hidden after combining a process
   with its local variables

ua returns the nesting depth of Atomic commands (always 0 or 1 after One_At)

SEv returns the signal events of each component: these must be disjoint sets.

--------------------------

The following function computes the readable and writable variables of an
individual thread together with its atomicity depth and signal events.                                

-}


Analyse1(Skip) = ({},{},{},{},0,{})
                   
Analyse1(Sq.(p,q)) = let
                    (IVW1,IVR1,BVW1,BVR1,ua1,se1) = Analyse1(p)
                    (IVW2,IVR2,BVW2,BVR2,ua2,se2) = Analyse1(q)
                   within
                    (
                     union(IVW1,IVW2),
                     union(IVR1,IVR2),
                     union(BVW1,BVW2),
                     union(BVR1,BVR2),
                     max(ua1, ua2), 
                     union(se1,se2)
                    ) 
                    
Analyse1(SQ.<>) = ({},{},{},{},0,{})
Analyse1(SQ.(<p>^ps)) = Analyse1(Sq.(p,SQ.ps))
                    
Analyse1(Iter.p) = Analyse1(p)
                    

Analyse1(Cond.(b,p,q)) = 
                   let
                    (IVW1,IVR1,BVW1,BVR1,ua1,se1) = Analyse1(p)
                    (IVW2,IVR2,BVW2,BVR2,ua2,se2) = Analyse1(q)
                    (IVs',BVs') = AnalyseB(b)
                   within
                    (
                     union(IVW1,IVW2),
                     Union({IVs',IVR1,IVR2}),
                     union(BVW1,BVW2),
                     Union({BVs',BVR1,BVR2}),
                       max(ua1, ua2),
                     union(se1,se2)
                    )

Analyse1(While.(b,P)) = Analyse1(Cond.(b,P,Skip))

      
Analyse1(Bassign.(e,b)) = 
                   let
                    (IVs,BVs) = AnalyseB(b)
                    (IVs',_) = AnalyseB(e)
                    bass(BVar.v) = {v}
                    bass(BArc.(v,e)) = {v.n | n <- itype(v)}
                   within
                      (
                       {},
                       union(IVs,IVs'),
                       bass(e),
                       BVs,
                       0,
                       {})

      
Analyse1(Iassign.(el,er)) = 
                   let
                    IVs= AnalyseI(er)
                    IVs'= AnalyseI(el)
                    iass(IVar.v) = {v}
                    iass(IArc.(v,e)) = {v.n | n <- itype(v)}
                   within
                      (
                       iass(el),
                       union(IVs,IVs'),
                       {},
                       {},
                       0,
                       {})

Analyse1(ISig.(c,e)) = 
                   let
                    IVs= AnalyseI(e)
                   within
                      (
                       {},
                       IVs,
                       {},
                       {},
                       0,
                       {|c|})

Analyse1(Sig.x) = ({},{},{},{},0,{x})

Analyse1(Atomic.p) = let (a,b,c,d,e,f) =Analyse1(p)
                     within (a,b,c,d,e+1,f)


-- The functions AnalyseI and AnalyseB produce the sets of variables readable in
-- computing integer and boolean expression values.

AnalyseI(Const.x) = {}
AnalyseI(IVar.x) = {x}
AnalyseI(IArc.(v,e)) = Union({
                             AnalyseI(e),
                             {v.x | x <- itype(v)}})
AnalyseI(BIOp._.a.b) = let 
                      IVs1 = AnalyseI(a)
                      IVs2 = AnalyseI(b)
                     within
                         union(IVs1,IVs2)
AnalyseI(UIOp._.a) = AnalyseI(a)
                    
AnalyseB(True) = ({},{})
AnalyseB(False) = ({},{})
AnalyseB(BVar.x) = ({},{x})
AnalyseB(BArc.(v,e)) = (AnalyseI(e),
                        {v.x | x <- itype(v)})
AnalyseB(BBOp._.a.b) = let 
                      (IVs1,BVs1) = AnalyseB(a)
                      (IVs2,BVs2) = AnalyseB(b)
                     within
                      (union(IVs1,IVs2),
                       union(BVs1,BVs2))
AnalyseB(Not.a) = AnalyseB(a) 

AnalyseB(CompOp._.a.b) = let 
                      IVs1 = AnalyseI(a)
                      IVs2 = AnalyseI(b)
                     within
                      (union(IVs1,IVs2),{})


-- Part 6. Compilation

-- The following converts a thread into its CSP simulation, at index j.
-- Note the use of the expression evaluation functions, taking subsequent
-- behaviour as a "continuation"

MainProc(Skip,j) = SKIP

MainProc(Sig.x,j) = x -> SKIP

MainProc(Sq.(p,q),j) = MainProc(p,j);MainProc(q,j)
MainProc(SQ.<>,j) = SKIP
MainProc(SQ.<p>^Ps,j) = MainProc(p,j);MainProc(SQ.Ps,j)

MainProc(Iter.p,j) = MainProc(p,j);MainProc(Iter.p,j)

MainProc(While.(b,p),j) = let P(x) =
                           if x then MainProc(p,j);MainProc(While.(b,p),j)
                           else SKIP
                          within BExpEval(b,P,j)
MainProc(Cond.(b,p,q),j) =  let P(x) =
                             if x then MainProc(p,j) else MainProc(q,j)
                          within BExpEval(b,P,j)

MainProc(Bassign.(el,e),j) = 
                          let Q(lv) =
                          let P(rv) = bvwrite.j.lv.rv -> 
                                       if member(lv,DirtyVars) 
                                         then bvwrite.j.lv.rv -> SKIP
                                         else SKIP
                              within BExpEval(e,P,j)
                          within BLvEval(el,Q,j)

MainProc(Iassign.(el,e),j) = 
                          let Q(lv) =
                          let P(rv) = if member(rv,ctype(lv)) then
                                     ivwrite.j.lv.rv -> 
                                       if member(lv,DirtyVars) 
                                          then ivwrite.j.lv.rv -> SKIP
                                          else SKIP
                                     else error.j -> STOP
                              within IExpEval(e,P,j)
                          within ILvEval(el,Q,j)

MainProc(ISig.(c,e),j) = let P(x) = c!x  -> SKIP
                          within IExpEval(e,P,j)


MainProc(Atomic.p,j) = start_at.j -> MainProc(p,j);end_at.j -> SKIP
MainProc(ErrorC,j) = error.j -> STOP

-- Some basic definitions
                   
max(a,b) = if a < b then b else a

listmax(<>) = 0
listmax(<a>^as) = max(a,listmax(as))


nth(<x>^xs,0) = x
nth(<x>^xs,m) = nth(xs,m-1)

-- Part 7.  Overseers

-- An overseer process synchronises on all reads and writes of the variables it
-- uses.  When it is inactive it will allow anybody to read or write such a
-- variable.  A read has no effect on it, but a write causes it to become active.
-- Once it has completed its activities it becomes active.

-- An overseer process is always given all its variables as local.  
-- This means that the
-- alphabet it is given will include all accesses of these variables.
-- The code that runs for an overseer in the absence of atomicity is as follows:

OvSrRun(P,k,IVs,BVs,pnumsl) = let 
              S = diff(pnumsl,{k})
              Inactive = iveval?j:S?v:IVs?_ -> Inactive
                         [] bveval?j:S?v:BVs?_ -> Inactive
                         [] ivwrite?j:S?v:IVs?_ -> P;Inactive
                         [] bvwrite?j:S?v:BVs?_ -> P;Inactive
              within
                Inactive

-- Here, IVs and BVs are the integer and boolean variables used by the overseer process P,
-- and k is the index of this process.

-- With atomicity, we have something to decide: does an atomic section have priority
-- over the overseer, or vice-versa.  There are arguments both ways, but we settle for
-- the former.  Therefore we should now have the overseer triggered by either one of
-- its variables being written outside an atomic section, or the ending of an atomic
-- section which included such a write.

OvSrRun_at(P,k,IVs,BVs,pnumsl) = 
              let 
              S = diff(pnumsl,{k})
              Inactive = iveval?j:S?v:IVs?_ -> Inactive
                         [] bveval?j:S?v:BVs?_ -> Inactive
                         [] ivwrite?j:S?v:IVs?_ -> P;Inactive
                         [] bvwrite?j:S?v:BVs?_ -> P;Inactive
                         [] start_at?j:diff(pnums'',{k}) -> Inactive_at(j)
              Inactive_at(j) = 
                            end_at!j -> Inactive
                         [] iveval.j?v:IVs?_ -> Inactive_at(j)
                         [] bveval.j?v:BVs?_ -> Inactive_at(j)
                         [] ivwrite.j?v:IVs?_ -> Active_at(j)
                         [] bvwrite.j?v:BVs?_ -> Active_at(j)
              Active_at(j) = 
                            end_at!j -> (P;Inactive)
                         [] iveval.j?v:IVs?_ -> Active_at(j)
                         [] bveval.j?v:BVs?_ -> Active_at(j)
                         [] ivwrite.j?v:IVs?_ -> Active_at(j)
                         [] bvwrite.j?v:BVs?_ -> Active_at(j)

              within
                Inactive

-- Structured compilation and compression


-- An add on for svacomp.csp to allow users to build and compress networks
-- of shared variable programs in a structured way using the following
-- structured type 

datatype CmdStruct = CSLeaf.Cmd | CSNode.Seq(CmdStruct) 
         | CSOverseer.Cmd

-- In order that we can take advantage of the methods used above for
-- compiling individual threads, we need functions that convert a CmdStruct
-- into a list, and a list of processes generated by the combination of this
-- and CompileList into the corresponding structure in PStruct (an analogous
-- type where the leaves are process/alphabet pairs). 

-- CSOverseer(P,Q) means that Q runs, monitored by P on the variables that they share:
-- whenever one of these variables is written by Q, P runs until it is finished, and
-- during this period P is not permitted to read or write any of the said variables.

CSFlatten(CSLeaf.C) = (<C>,{})
CSFlatten(CSOverseer.C) = (<C>,{0})
CSFlatten(CSNode.ts) = let ps = <CSFlatten(t)| t <- ts>
                           Reduce(Cs,Ms,n,<>) = (Cs,Ms) 
                           Reduce(Cs,Ms,n,<(Csx,Msx)>^ps) =
                             Reduce(Cs^Csx,union(Ms,{r+n | r <- Msx}),n+#Csx,ps)
                          within
                           Reduce(<>,{},0,ps)
 

UnFlatten(CSLeaf._,<(P,A)>^ps) = (PSLeaf.(P,A),ps)
UnFlatten(CSOverseer._,<(P,A)>^ps) = (PSLeaf.(P,A),ps)
UnFlatten(CSNode.<t>,ps) = let (pt,ps') = UnFlatten(t,ps)
                           within (PSNode.<pt>,ps')
UnFlatten(CSNode.(<t>^ts),ps) = let (pt,ps') = UnFlatten(t,ps)
                                    (PSNode.ts',ps'') = UnFlatten(CSNode.ts,ps')
                           within (PSNode.<pt>^ts',ps'')


CompiledStructure(ct) = let (Cs,OvSrs) = CSFlatten(ct)
                            (pt,_) = UnFlatten(ct,CompileList(Cs,OvSrs))
                        within pt

CompiledStructureA(ct) = let (Cs,OvSrs) = CSFlatten(ct)
                            pt = CompileListA(Cs,OvSrs)
                        within pt

-- We can now apply functions defined within compression09.csp to complete the
-- compilation.

-- The first just compiles without compression.

StructuredCompile(ct)(AS) = StructPar(CompiledStructure(ct))
                           \(diff(Events, AS))

-- The second compresses the individual process/variable combinations, as
-- in CompressedCompile

LeafCompressedStructuredCompile(ct)(AS) = PSLeafCompress(compress)(CompiledStructure(ct))(diff(Events, AS))

-- The final one composes and compresses all the Nodes in the tree ct other
-- than the top level one.

HierarchCompressedCompile(ct)(AS) = PSStructCompress(compress)(
                                CompiledStructure(ct)) (diff(Events,AS))
                                     

-- How well this works will depend on the nature of the network; for example
-- how many locations disappear within the subnetworks.

HierarchCompressedCompileN(ct)(AS) = PSStructCompress(normal)(
                                CompiledStructure(ct)) (diff(Events,AS))
                                     

